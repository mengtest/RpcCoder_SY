// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BagRpc.proto

#ifndef PROTOBUF_BagRpc_2eproto__INCLUDED
#define PROTOBUF_BagRpc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "PublicStruct.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_BagRpc_2eproto();
void protobuf_AssignDesc_BagRpc_2eproto();
void protobuf_ShutdownFile_BagRpc_2eproto();

class BagRpcUseItemAsk;
class BagRpcUseItemReply;
class BagRpcSyncAsk;
class BagRpcSyncReply;
class BagRpcSaleItemAsk;
class BagRpcSaleItemReply;
class BagRpcLockItemAsk;
class BagRpcLockItemReply;
class BagRpcDeblockingAsk;
class BagRpcDeblockingReply;
class BagRpcTakeItemAsk;
class BagRpcTakeItemReply;
class BagRpcTidyAsk;
class BagRpcTidyReply;
class BagRpcTakeAllBackBagsAsk;
class BagRpcTakeAllBackBagsReply;
class BagRpcBagChangeNotify;

// ===================================================================

class BagRpcUseItemAsk : public ::google::protobuf::Message {
 public:
  BagRpcUseItemAsk();
  virtual ~BagRpcUseItemAsk();

  BagRpcUseItemAsk(const BagRpcUseItemAsk& from);

  inline BagRpcUseItemAsk& operator=(const BagRpcUseItemAsk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BagRpcUseItemAsk& default_instance();

  void Swap(BagRpcUseItemAsk* other);

  // implements Message ----------------------------------------------

  BagRpcUseItemAsk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BagRpcUseItemAsk& from);
  void MergeFrom(const BagRpcUseItemAsk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Count = 1 [default = -1];
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional sint32 Pos = 2 [default = -1];
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 2;
  inline ::google::protobuf::int32 pos() const;
  inline void set_pos(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BagRpcUseItemAsk)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BagRpc_2eproto();
  friend void protobuf_AssignDesc_BagRpc_2eproto();
  friend void protobuf_ShutdownFile_BagRpc_2eproto();

  void InitAsDefaultInstance();
  static BagRpcUseItemAsk* default_instance_;
};
// -------------------------------------------------------------------

class BagRpcUseItemReply : public ::google::protobuf::Message {
 public:
  BagRpcUseItemReply();
  virtual ~BagRpcUseItemReply();

  BagRpcUseItemReply(const BagRpcUseItemReply& from);

  inline BagRpcUseItemReply& operator=(const BagRpcUseItemReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BagRpcUseItemReply& default_instance();

  void Swap(BagRpcUseItemReply* other);

  // implements Message ----------------------------------------------

  BagRpcUseItemReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BagRpcUseItemReply& from);
  void MergeFrom(const BagRpcUseItemReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Result = 1 [default = -9999];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .ItemObj Item = 2;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 2;
  inline const ::ItemObj& item() const;
  inline ::ItemObj* mutable_item();
  inline ::ItemObj* release_item();
  inline void set_allocated_item(::ItemObj* item);

  // @@protoc_insertion_point(class_scope:BagRpcUseItemReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_item();
  inline void clear_has_item();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ItemObj* item_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BagRpc_2eproto();
  friend void protobuf_AssignDesc_BagRpc_2eproto();
  friend void protobuf_ShutdownFile_BagRpc_2eproto();

  void InitAsDefaultInstance();
  static BagRpcUseItemReply* default_instance_;
};
// -------------------------------------------------------------------

class BagRpcSyncAsk : public ::google::protobuf::Message {
 public:
  BagRpcSyncAsk();
  virtual ~BagRpcSyncAsk();

  BagRpcSyncAsk(const BagRpcSyncAsk& from);

  inline BagRpcSyncAsk& operator=(const BagRpcSyncAsk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BagRpcSyncAsk& default_instance();

  void Swap(BagRpcSyncAsk* other);

  // implements Message ----------------------------------------------

  BagRpcSyncAsk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BagRpcSyncAsk& from);
  void MergeFrom(const BagRpcSyncAsk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:BagRpcSyncAsk)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_BagRpc_2eproto();
  friend void protobuf_AssignDesc_BagRpc_2eproto();
  friend void protobuf_ShutdownFile_BagRpc_2eproto();

  void InitAsDefaultInstance();
  static BagRpcSyncAsk* default_instance_;
};
// -------------------------------------------------------------------

class BagRpcSyncReply : public ::google::protobuf::Message {
 public:
  BagRpcSyncReply();
  virtual ~BagRpcSyncReply();

  BagRpcSyncReply(const BagRpcSyncReply& from);

  inline BagRpcSyncReply& operator=(const BagRpcSyncReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BagRpcSyncReply& default_instance();

  void Swap(BagRpcSyncReply* other);

  // implements Message ----------------------------------------------

  BagRpcSyncReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BagRpcSyncReply& from);
  void MergeFrom(const BagRpcSyncReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Result = 1 [default = -9999];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // repeated .BagData Bags = 2;
  inline int bags_size() const;
  inline void clear_bags();
  static const int kBagsFieldNumber = 2;
  inline const ::BagData& bags(int index) const;
  inline ::BagData* mutable_bags(int index);
  inline ::BagData* add_bags();
  inline const ::google::protobuf::RepeatedPtrField< ::BagData >&
      bags() const;
  inline ::google::protobuf::RepeatedPtrField< ::BagData >*
      mutable_bags();

  // @@protoc_insertion_point(class_scope:BagRpcSyncReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::BagData > bags_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BagRpc_2eproto();
  friend void protobuf_AssignDesc_BagRpc_2eproto();
  friend void protobuf_ShutdownFile_BagRpc_2eproto();

  void InitAsDefaultInstance();
  static BagRpcSyncReply* default_instance_;
};
// -------------------------------------------------------------------

class BagRpcSaleItemAsk : public ::google::protobuf::Message {
 public:
  BagRpcSaleItemAsk();
  virtual ~BagRpcSaleItemAsk();

  BagRpcSaleItemAsk(const BagRpcSaleItemAsk& from);

  inline BagRpcSaleItemAsk& operator=(const BagRpcSaleItemAsk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BagRpcSaleItemAsk& default_instance();

  void Swap(BagRpcSaleItemAsk* other);

  // implements Message ----------------------------------------------

  BagRpcSaleItemAsk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BagRpcSaleItemAsk& from);
  void MergeFrom(const BagRpcSaleItemAsk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Pos = 5 [default = -1];
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 5;
  inline ::google::protobuf::int32 pos() const;
  inline void set_pos(::google::protobuf::int32 value);

  // optional sint32 Count = 6 [default = -1];
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 6;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BagRpcSaleItemAsk)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 pos_;
  ::google::protobuf::int32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BagRpc_2eproto();
  friend void protobuf_AssignDesc_BagRpc_2eproto();
  friend void protobuf_ShutdownFile_BagRpc_2eproto();

  void InitAsDefaultInstance();
  static BagRpcSaleItemAsk* default_instance_;
};
// -------------------------------------------------------------------

class BagRpcSaleItemReply : public ::google::protobuf::Message {
 public:
  BagRpcSaleItemReply();
  virtual ~BagRpcSaleItemReply();

  BagRpcSaleItemReply(const BagRpcSaleItemReply& from);

  inline BagRpcSaleItemReply& operator=(const BagRpcSaleItemReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BagRpcSaleItemReply& default_instance();

  void Swap(BagRpcSaleItemReply* other);

  // implements Message ----------------------------------------------

  BagRpcSaleItemReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BagRpcSaleItemReply& from);
  void MergeFrom(const BagRpcSaleItemReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Result = 1 [default = -9999];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .ItemObj Item = 4;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 4;
  inline const ::ItemObj& item() const;
  inline ::ItemObj* mutable_item();
  inline ::ItemObj* release_item();
  inline void set_allocated_item(::ItemObj* item);

  // @@protoc_insertion_point(class_scope:BagRpcSaleItemReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_item();
  inline void clear_has_item();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ItemObj* item_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BagRpc_2eproto();
  friend void protobuf_AssignDesc_BagRpc_2eproto();
  friend void protobuf_ShutdownFile_BagRpc_2eproto();

  void InitAsDefaultInstance();
  static BagRpcSaleItemReply* default_instance_;
};
// -------------------------------------------------------------------

class BagRpcLockItemAsk : public ::google::protobuf::Message {
 public:
  BagRpcLockItemAsk();
  virtual ~BagRpcLockItemAsk();

  BagRpcLockItemAsk(const BagRpcLockItemAsk& from);

  inline BagRpcLockItemAsk& operator=(const BagRpcLockItemAsk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BagRpcLockItemAsk& default_instance();

  void Swap(BagRpcLockItemAsk* other);

  // implements Message ----------------------------------------------

  BagRpcLockItemAsk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BagRpcLockItemAsk& from);
  void MergeFrom(const BagRpcLockItemAsk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Pos = 1 [default = -1];
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::int32 pos() const;
  inline void set_pos(::google::protobuf::int32 value);

  // optional bool IsLock = 3 [default = false];
  inline bool has_islock() const;
  inline void clear_islock();
  static const int kIsLockFieldNumber = 3;
  inline bool islock() const;
  inline void set_islock(bool value);

  // @@protoc_insertion_point(class_scope:BagRpcLockItemAsk)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_islock();
  inline void clear_has_islock();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 pos_;
  bool islock_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BagRpc_2eproto();
  friend void protobuf_AssignDesc_BagRpc_2eproto();
  friend void protobuf_ShutdownFile_BagRpc_2eproto();

  void InitAsDefaultInstance();
  static BagRpcLockItemAsk* default_instance_;
};
// -------------------------------------------------------------------

class BagRpcLockItemReply : public ::google::protobuf::Message {
 public:
  BagRpcLockItemReply();
  virtual ~BagRpcLockItemReply();

  BagRpcLockItemReply(const BagRpcLockItemReply& from);

  inline BagRpcLockItemReply& operator=(const BagRpcLockItemReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BagRpcLockItemReply& default_instance();

  void Swap(BagRpcLockItemReply* other);

  // implements Message ----------------------------------------------

  BagRpcLockItemReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BagRpcLockItemReply& from);
  void MergeFrom(const BagRpcLockItemReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Result = 1 [default = -9999];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .ItemObj Item = 5;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 5;
  inline const ::ItemObj& item() const;
  inline ::ItemObj* mutable_item();
  inline ::ItemObj* release_item();
  inline void set_allocated_item(::ItemObj* item);

  // @@protoc_insertion_point(class_scope:BagRpcLockItemReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_item();
  inline void clear_has_item();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ItemObj* item_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BagRpc_2eproto();
  friend void protobuf_AssignDesc_BagRpc_2eproto();
  friend void protobuf_ShutdownFile_BagRpc_2eproto();

  void InitAsDefaultInstance();
  static BagRpcLockItemReply* default_instance_;
};
// -------------------------------------------------------------------

class BagRpcDeblockingAsk : public ::google::protobuf::Message {
 public:
  BagRpcDeblockingAsk();
  virtual ~BagRpcDeblockingAsk();

  BagRpcDeblockingAsk(const BagRpcDeblockingAsk& from);

  inline BagRpcDeblockingAsk& operator=(const BagRpcDeblockingAsk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BagRpcDeblockingAsk& default_instance();

  void Swap(BagRpcDeblockingAsk* other);

  // implements Message ----------------------------------------------

  BagRpcDeblockingAsk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BagRpcDeblockingAsk& from);
  void MergeFrom(const BagRpcDeblockingAsk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 BagType = 1 [default = -1];
  inline bool has_bagtype() const;
  inline void clear_bagtype();
  static const int kBagTypeFieldNumber = 1;
  inline ::google::protobuf::int32 bagtype() const;
  inline void set_bagtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BagRpcDeblockingAsk)
 private:
  inline void set_has_bagtype();
  inline void clear_has_bagtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 bagtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_BagRpc_2eproto();
  friend void protobuf_AssignDesc_BagRpc_2eproto();
  friend void protobuf_ShutdownFile_BagRpc_2eproto();

  void InitAsDefaultInstance();
  static BagRpcDeblockingAsk* default_instance_;
};
// -------------------------------------------------------------------

class BagRpcDeblockingReply : public ::google::protobuf::Message {
 public:
  BagRpcDeblockingReply();
  virtual ~BagRpcDeblockingReply();

  BagRpcDeblockingReply(const BagRpcDeblockingReply& from);

  inline BagRpcDeblockingReply& operator=(const BagRpcDeblockingReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BagRpcDeblockingReply& default_instance();

  void Swap(BagRpcDeblockingReply* other);

  // implements Message ----------------------------------------------

  BagRpcDeblockingReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BagRpcDeblockingReply& from);
  void MergeFrom(const BagRpcDeblockingReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Result = 1 [default = -9999];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional sint32 BagType = 2 [default = -1];
  inline bool has_bagtype() const;
  inline void clear_bagtype();
  static const int kBagTypeFieldNumber = 2;
  inline ::google::protobuf::int32 bagtype() const;
  inline void set_bagtype(::google::protobuf::int32 value);

  // optional sint32 CurCapacity = 3 [default = -1];
  inline bool has_curcapacity() const;
  inline void clear_curcapacity();
  static const int kCurCapacityFieldNumber = 3;
  inline ::google::protobuf::int32 curcapacity() const;
  inline void set_curcapacity(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BagRpcDeblockingReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_bagtype();
  inline void clear_has_bagtype();
  inline void set_has_curcapacity();
  inline void clear_has_curcapacity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 bagtype_;
  ::google::protobuf::int32 curcapacity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_BagRpc_2eproto();
  friend void protobuf_AssignDesc_BagRpc_2eproto();
  friend void protobuf_ShutdownFile_BagRpc_2eproto();

  void InitAsDefaultInstance();
  static BagRpcDeblockingReply* default_instance_;
};
// -------------------------------------------------------------------

class BagRpcTakeItemAsk : public ::google::protobuf::Message {
 public:
  BagRpcTakeItemAsk();
  virtual ~BagRpcTakeItemAsk();

  BagRpcTakeItemAsk(const BagRpcTakeItemAsk& from);

  inline BagRpcTakeItemAsk& operator=(const BagRpcTakeItemAsk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BagRpcTakeItemAsk& default_instance();

  void Swap(BagRpcTakeItemAsk* other);

  // implements Message ----------------------------------------------

  BagRpcTakeItemAsk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BagRpcTakeItemAsk& from);
  void MergeFrom(const BagRpcTakeItemAsk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 FromBagType = 1 [default = -1];
  inline bool has_frombagtype() const;
  inline void clear_frombagtype();
  static const int kFromBagTypeFieldNumber = 1;
  inline ::google::protobuf::int32 frombagtype() const;
  inline void set_frombagtype(::google::protobuf::int32 value);

  // optional sint32 ToBagType = 2 [default = -1];
  inline bool has_tobagtype() const;
  inline void clear_tobagtype();
  static const int kToBagTypeFieldNumber = 2;
  inline ::google::protobuf::int32 tobagtype() const;
  inline void set_tobagtype(::google::protobuf::int32 value);

  // optional sint32 FromPos = 3 [default = -1];
  inline bool has_frompos() const;
  inline void clear_frompos();
  static const int kFromPosFieldNumber = 3;
  inline ::google::protobuf::int32 frompos() const;
  inline void set_frompos(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BagRpcTakeItemAsk)
 private:
  inline void set_has_frombagtype();
  inline void clear_has_frombagtype();
  inline void set_has_tobagtype();
  inline void clear_has_tobagtype();
  inline void set_has_frompos();
  inline void clear_has_frompos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 frombagtype_;
  ::google::protobuf::int32 tobagtype_;
  ::google::protobuf::int32 frompos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_BagRpc_2eproto();
  friend void protobuf_AssignDesc_BagRpc_2eproto();
  friend void protobuf_ShutdownFile_BagRpc_2eproto();

  void InitAsDefaultInstance();
  static BagRpcTakeItemAsk* default_instance_;
};
// -------------------------------------------------------------------

class BagRpcTakeItemReply : public ::google::protobuf::Message {
 public:
  BagRpcTakeItemReply();
  virtual ~BagRpcTakeItemReply();

  BagRpcTakeItemReply(const BagRpcTakeItemReply& from);

  inline BagRpcTakeItemReply& operator=(const BagRpcTakeItemReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BagRpcTakeItemReply& default_instance();

  void Swap(BagRpcTakeItemReply* other);

  // implements Message ----------------------------------------------

  BagRpcTakeItemReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BagRpcTakeItemReply& from);
  void MergeFrom(const BagRpcTakeItemReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Result = 1 [default = -9999];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .ItemObj ToItemObj = 2;
  inline bool has_toitemobj() const;
  inline void clear_toitemobj();
  static const int kToItemObjFieldNumber = 2;
  inline const ::ItemObj& toitemobj() const;
  inline ::ItemObj* mutable_toitemobj();
  inline ::ItemObj* release_toitemobj();
  inline void set_allocated_toitemobj(::ItemObj* toitemobj);

  // optional .ItemObj FromItemObj = 3;
  inline bool has_fromitemobj() const;
  inline void clear_fromitemobj();
  static const int kFromItemObjFieldNumber = 3;
  inline const ::ItemObj& fromitemobj() const;
  inline ::ItemObj* mutable_fromitemobj();
  inline ::ItemObj* release_fromitemobj();
  inline void set_allocated_fromitemobj(::ItemObj* fromitemobj);

  // optional sint32 FromBagType = 4 [default = -1];
  inline bool has_frombagtype() const;
  inline void clear_frombagtype();
  static const int kFromBagTypeFieldNumber = 4;
  inline ::google::protobuf::int32 frombagtype() const;
  inline void set_frombagtype(::google::protobuf::int32 value);

  // optional sint32 ToBagType = 5 [default = -1];
  inline bool has_tobagtype() const;
  inline void clear_tobagtype();
  static const int kToBagTypeFieldNumber = 5;
  inline ::google::protobuf::int32 tobagtype() const;
  inline void set_tobagtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BagRpcTakeItemReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_toitemobj();
  inline void clear_has_toitemobj();
  inline void set_has_fromitemobj();
  inline void clear_has_fromitemobj();
  inline void set_has_frombagtype();
  inline void clear_has_frombagtype();
  inline void set_has_tobagtype();
  inline void clear_has_tobagtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ItemObj* toitemobj_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 frombagtype_;
  ::ItemObj* fromitemobj_;
  ::google::protobuf::int32 tobagtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_BagRpc_2eproto();
  friend void protobuf_AssignDesc_BagRpc_2eproto();
  friend void protobuf_ShutdownFile_BagRpc_2eproto();

  void InitAsDefaultInstance();
  static BagRpcTakeItemReply* default_instance_;
};
// -------------------------------------------------------------------

class BagRpcTidyAsk : public ::google::protobuf::Message {
 public:
  BagRpcTidyAsk();
  virtual ~BagRpcTidyAsk();

  BagRpcTidyAsk(const BagRpcTidyAsk& from);

  inline BagRpcTidyAsk& operator=(const BagRpcTidyAsk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BagRpcTidyAsk& default_instance();

  void Swap(BagRpcTidyAsk* other);

  // implements Message ----------------------------------------------

  BagRpcTidyAsk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BagRpcTidyAsk& from);
  void MergeFrom(const BagRpcTidyAsk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 BagType = 2 [default = -1];
  inline bool has_bagtype() const;
  inline void clear_bagtype();
  static const int kBagTypeFieldNumber = 2;
  inline ::google::protobuf::int32 bagtype() const;
  inline void set_bagtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BagRpcTidyAsk)
 private:
  inline void set_has_bagtype();
  inline void clear_has_bagtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 bagtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_BagRpc_2eproto();
  friend void protobuf_AssignDesc_BagRpc_2eproto();
  friend void protobuf_ShutdownFile_BagRpc_2eproto();

  void InitAsDefaultInstance();
  static BagRpcTidyAsk* default_instance_;
};
// -------------------------------------------------------------------

class BagRpcTidyReply : public ::google::protobuf::Message {
 public:
  BagRpcTidyReply();
  virtual ~BagRpcTidyReply();

  BagRpcTidyReply(const BagRpcTidyReply& from);

  inline BagRpcTidyReply& operator=(const BagRpcTidyReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BagRpcTidyReply& default_instance();

  void Swap(BagRpcTidyReply* other);

  // implements Message ----------------------------------------------

  BagRpcTidyReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BagRpcTidyReply& from);
  void MergeFrom(const BagRpcTidyReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Result = 1 [default = -9999];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // repeated .BagData Bags = 3;
  inline int bags_size() const;
  inline void clear_bags();
  static const int kBagsFieldNumber = 3;
  inline const ::BagData& bags(int index) const;
  inline ::BagData* mutable_bags(int index);
  inline ::BagData* add_bags();
  inline const ::google::protobuf::RepeatedPtrField< ::BagData >&
      bags() const;
  inline ::google::protobuf::RepeatedPtrField< ::BagData >*
      mutable_bags();

  // optional sint32 BagType = 4 [default = -1];
  inline bool has_bagtype() const;
  inline void clear_bagtype();
  static const int kBagTypeFieldNumber = 4;
  inline ::google::protobuf::int32 bagtype() const;
  inline void set_bagtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BagRpcTidyReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_bagtype();
  inline void clear_has_bagtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::BagData > bags_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 bagtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_BagRpc_2eproto();
  friend void protobuf_AssignDesc_BagRpc_2eproto();
  friend void protobuf_ShutdownFile_BagRpc_2eproto();

  void InitAsDefaultInstance();
  static BagRpcTidyReply* default_instance_;
};
// -------------------------------------------------------------------

class BagRpcTakeAllBackBagsAsk : public ::google::protobuf::Message {
 public:
  BagRpcTakeAllBackBagsAsk();
  virtual ~BagRpcTakeAllBackBagsAsk();

  BagRpcTakeAllBackBagsAsk(const BagRpcTakeAllBackBagsAsk& from);

  inline BagRpcTakeAllBackBagsAsk& operator=(const BagRpcTakeAllBackBagsAsk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BagRpcTakeAllBackBagsAsk& default_instance();

  void Swap(BagRpcTakeAllBackBagsAsk* other);

  // implements Message ----------------------------------------------

  BagRpcTakeAllBackBagsAsk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BagRpcTakeAllBackBagsAsk& from);
  void MergeFrom(const BagRpcTakeAllBackBagsAsk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:BagRpcTakeAllBackBagsAsk)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_BagRpc_2eproto();
  friend void protobuf_AssignDesc_BagRpc_2eproto();
  friend void protobuf_ShutdownFile_BagRpc_2eproto();

  void InitAsDefaultInstance();
  static BagRpcTakeAllBackBagsAsk* default_instance_;
};
// -------------------------------------------------------------------

class BagRpcTakeAllBackBagsReply : public ::google::protobuf::Message {
 public:
  BagRpcTakeAllBackBagsReply();
  virtual ~BagRpcTakeAllBackBagsReply();

  BagRpcTakeAllBackBagsReply(const BagRpcTakeAllBackBagsReply& from);

  inline BagRpcTakeAllBackBagsReply& operator=(const BagRpcTakeAllBackBagsReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BagRpcTakeAllBackBagsReply& default_instance();

  void Swap(BagRpcTakeAllBackBagsReply* other);

  // implements Message ----------------------------------------------

  BagRpcTakeAllBackBagsReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BagRpcTakeAllBackBagsReply& from);
  void MergeFrom(const BagRpcTakeAllBackBagsReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Result = 1 [default = -9999];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // repeated .BagData Bags = 2;
  inline int bags_size() const;
  inline void clear_bags();
  static const int kBagsFieldNumber = 2;
  inline const ::BagData& bags(int index) const;
  inline ::BagData* mutable_bags(int index);
  inline ::BagData* add_bags();
  inline const ::google::protobuf::RepeatedPtrField< ::BagData >&
      bags() const;
  inline ::google::protobuf::RepeatedPtrField< ::BagData >*
      mutable_bags();

  // @@protoc_insertion_point(class_scope:BagRpcTakeAllBackBagsReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::BagData > bags_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BagRpc_2eproto();
  friend void protobuf_AssignDesc_BagRpc_2eproto();
  friend void protobuf_ShutdownFile_BagRpc_2eproto();

  void InitAsDefaultInstance();
  static BagRpcTakeAllBackBagsReply* default_instance_;
};
// -------------------------------------------------------------------

class BagRpcBagChangeNotify : public ::google::protobuf::Message {
 public:
  BagRpcBagChangeNotify();
  virtual ~BagRpcBagChangeNotify();

  BagRpcBagChangeNotify(const BagRpcBagChangeNotify& from);

  inline BagRpcBagChangeNotify& operator=(const BagRpcBagChangeNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BagRpcBagChangeNotify& default_instance();

  void Swap(BagRpcBagChangeNotify* other);

  // implements Message ----------------------------------------------

  BagRpcBagChangeNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BagRpcBagChangeNotify& from);
  void MergeFrom(const BagRpcBagChangeNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Result = 1 [default = -9999];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .BagData Bags = 2;
  inline bool has_bags() const;
  inline void clear_bags();
  static const int kBagsFieldNumber = 2;
  inline const ::BagData& bags() const;
  inline ::BagData* mutable_bags();
  inline ::BagData* release_bags();
  inline void set_allocated_bags(::BagData* bags);

  // @@protoc_insertion_point(class_scope:BagRpcBagChangeNotify)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_bags();
  inline void clear_has_bags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::BagData* bags_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BagRpc_2eproto();
  friend void protobuf_AssignDesc_BagRpc_2eproto();
  friend void protobuf_ShutdownFile_BagRpc_2eproto();

  void InitAsDefaultInstance();
  static BagRpcBagChangeNotify* default_instance_;
};
// ===================================================================


// ===================================================================

// BagRpcUseItemAsk

// optional sint32 Count = 1 [default = -1];
inline bool BagRpcUseItemAsk::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BagRpcUseItemAsk::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BagRpcUseItemAsk::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BagRpcUseItemAsk::clear_count() {
  count_ = -1;
  clear_has_count();
}
inline ::google::protobuf::int32 BagRpcUseItemAsk::count() const {
  return count_;
}
inline void BagRpcUseItemAsk::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// optional sint32 Pos = 2 [default = -1];
inline bool BagRpcUseItemAsk::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BagRpcUseItemAsk::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BagRpcUseItemAsk::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BagRpcUseItemAsk::clear_pos() {
  pos_ = -1;
  clear_has_pos();
}
inline ::google::protobuf::int32 BagRpcUseItemAsk::pos() const {
  return pos_;
}
inline void BagRpcUseItemAsk::set_pos(::google::protobuf::int32 value) {
  set_has_pos();
  pos_ = value;
}

// -------------------------------------------------------------------

// BagRpcUseItemReply

// optional sint32 Result = 1 [default = -9999];
inline bool BagRpcUseItemReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BagRpcUseItemReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BagRpcUseItemReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BagRpcUseItemReply::clear_result() {
  result_ = -9999;
  clear_has_result();
}
inline ::google::protobuf::int32 BagRpcUseItemReply::result() const {
  return result_;
}
inline void BagRpcUseItemReply::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .ItemObj Item = 2;
inline bool BagRpcUseItemReply::has_item() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BagRpcUseItemReply::set_has_item() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BagRpcUseItemReply::clear_has_item() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BagRpcUseItemReply::clear_item() {
  if (item_ != NULL) item_->::ItemObj::Clear();
  clear_has_item();
}
inline const ::ItemObj& BagRpcUseItemReply::item() const {
  return item_ != NULL ? *item_ : *default_instance_->item_;
}
inline ::ItemObj* BagRpcUseItemReply::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::ItemObj;
  return item_;
}
inline ::ItemObj* BagRpcUseItemReply::release_item() {
  clear_has_item();
  ::ItemObj* temp = item_;
  item_ = NULL;
  return temp;
}
inline void BagRpcUseItemReply::set_allocated_item(::ItemObj* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
}

// -------------------------------------------------------------------

// BagRpcSyncAsk

// -------------------------------------------------------------------

// BagRpcSyncReply

// optional sint32 Result = 1 [default = -9999];
inline bool BagRpcSyncReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BagRpcSyncReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BagRpcSyncReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BagRpcSyncReply::clear_result() {
  result_ = -9999;
  clear_has_result();
}
inline ::google::protobuf::int32 BagRpcSyncReply::result() const {
  return result_;
}
inline void BagRpcSyncReply::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// repeated .BagData Bags = 2;
inline int BagRpcSyncReply::bags_size() const {
  return bags_.size();
}
inline void BagRpcSyncReply::clear_bags() {
  bags_.Clear();
}
inline const ::BagData& BagRpcSyncReply::bags(int index) const {
  return bags_.Get(index);
}
inline ::BagData* BagRpcSyncReply::mutable_bags(int index) {
  return bags_.Mutable(index);
}
inline ::BagData* BagRpcSyncReply::add_bags() {
  return bags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BagData >&
BagRpcSyncReply::bags() const {
  return bags_;
}
inline ::google::protobuf::RepeatedPtrField< ::BagData >*
BagRpcSyncReply::mutable_bags() {
  return &bags_;
}

// -------------------------------------------------------------------

// BagRpcSaleItemAsk

// optional sint32 Pos = 5 [default = -1];
inline bool BagRpcSaleItemAsk::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BagRpcSaleItemAsk::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BagRpcSaleItemAsk::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BagRpcSaleItemAsk::clear_pos() {
  pos_ = -1;
  clear_has_pos();
}
inline ::google::protobuf::int32 BagRpcSaleItemAsk::pos() const {
  return pos_;
}
inline void BagRpcSaleItemAsk::set_pos(::google::protobuf::int32 value) {
  set_has_pos();
  pos_ = value;
}

// optional sint32 Count = 6 [default = -1];
inline bool BagRpcSaleItemAsk::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BagRpcSaleItemAsk::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BagRpcSaleItemAsk::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BagRpcSaleItemAsk::clear_count() {
  count_ = -1;
  clear_has_count();
}
inline ::google::protobuf::int32 BagRpcSaleItemAsk::count() const {
  return count_;
}
inline void BagRpcSaleItemAsk::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// BagRpcSaleItemReply

// optional sint32 Result = 1 [default = -9999];
inline bool BagRpcSaleItemReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BagRpcSaleItemReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BagRpcSaleItemReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BagRpcSaleItemReply::clear_result() {
  result_ = -9999;
  clear_has_result();
}
inline ::google::protobuf::int32 BagRpcSaleItemReply::result() const {
  return result_;
}
inline void BagRpcSaleItemReply::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .ItemObj Item = 4;
inline bool BagRpcSaleItemReply::has_item() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BagRpcSaleItemReply::set_has_item() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BagRpcSaleItemReply::clear_has_item() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BagRpcSaleItemReply::clear_item() {
  if (item_ != NULL) item_->::ItemObj::Clear();
  clear_has_item();
}
inline const ::ItemObj& BagRpcSaleItemReply::item() const {
  return item_ != NULL ? *item_ : *default_instance_->item_;
}
inline ::ItemObj* BagRpcSaleItemReply::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::ItemObj;
  return item_;
}
inline ::ItemObj* BagRpcSaleItemReply::release_item() {
  clear_has_item();
  ::ItemObj* temp = item_;
  item_ = NULL;
  return temp;
}
inline void BagRpcSaleItemReply::set_allocated_item(::ItemObj* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
}

// -------------------------------------------------------------------

// BagRpcLockItemAsk

// optional sint32 Pos = 1 [default = -1];
inline bool BagRpcLockItemAsk::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BagRpcLockItemAsk::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BagRpcLockItemAsk::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BagRpcLockItemAsk::clear_pos() {
  pos_ = -1;
  clear_has_pos();
}
inline ::google::protobuf::int32 BagRpcLockItemAsk::pos() const {
  return pos_;
}
inline void BagRpcLockItemAsk::set_pos(::google::protobuf::int32 value) {
  set_has_pos();
  pos_ = value;
}

// optional bool IsLock = 3 [default = false];
inline bool BagRpcLockItemAsk::has_islock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BagRpcLockItemAsk::set_has_islock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BagRpcLockItemAsk::clear_has_islock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BagRpcLockItemAsk::clear_islock() {
  islock_ = false;
  clear_has_islock();
}
inline bool BagRpcLockItemAsk::islock() const {
  return islock_;
}
inline void BagRpcLockItemAsk::set_islock(bool value) {
  set_has_islock();
  islock_ = value;
}

// -------------------------------------------------------------------

// BagRpcLockItemReply

// optional sint32 Result = 1 [default = -9999];
inline bool BagRpcLockItemReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BagRpcLockItemReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BagRpcLockItemReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BagRpcLockItemReply::clear_result() {
  result_ = -9999;
  clear_has_result();
}
inline ::google::protobuf::int32 BagRpcLockItemReply::result() const {
  return result_;
}
inline void BagRpcLockItemReply::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .ItemObj Item = 5;
inline bool BagRpcLockItemReply::has_item() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BagRpcLockItemReply::set_has_item() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BagRpcLockItemReply::clear_has_item() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BagRpcLockItemReply::clear_item() {
  if (item_ != NULL) item_->::ItemObj::Clear();
  clear_has_item();
}
inline const ::ItemObj& BagRpcLockItemReply::item() const {
  return item_ != NULL ? *item_ : *default_instance_->item_;
}
inline ::ItemObj* BagRpcLockItemReply::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::ItemObj;
  return item_;
}
inline ::ItemObj* BagRpcLockItemReply::release_item() {
  clear_has_item();
  ::ItemObj* temp = item_;
  item_ = NULL;
  return temp;
}
inline void BagRpcLockItemReply::set_allocated_item(::ItemObj* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
}

// -------------------------------------------------------------------

// BagRpcDeblockingAsk

// optional sint32 BagType = 1 [default = -1];
inline bool BagRpcDeblockingAsk::has_bagtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BagRpcDeblockingAsk::set_has_bagtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BagRpcDeblockingAsk::clear_has_bagtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BagRpcDeblockingAsk::clear_bagtype() {
  bagtype_ = -1;
  clear_has_bagtype();
}
inline ::google::protobuf::int32 BagRpcDeblockingAsk::bagtype() const {
  return bagtype_;
}
inline void BagRpcDeblockingAsk::set_bagtype(::google::protobuf::int32 value) {
  set_has_bagtype();
  bagtype_ = value;
}

// -------------------------------------------------------------------

// BagRpcDeblockingReply

// optional sint32 Result = 1 [default = -9999];
inline bool BagRpcDeblockingReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BagRpcDeblockingReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BagRpcDeblockingReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BagRpcDeblockingReply::clear_result() {
  result_ = -9999;
  clear_has_result();
}
inline ::google::protobuf::int32 BagRpcDeblockingReply::result() const {
  return result_;
}
inline void BagRpcDeblockingReply::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional sint32 BagType = 2 [default = -1];
inline bool BagRpcDeblockingReply::has_bagtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BagRpcDeblockingReply::set_has_bagtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BagRpcDeblockingReply::clear_has_bagtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BagRpcDeblockingReply::clear_bagtype() {
  bagtype_ = -1;
  clear_has_bagtype();
}
inline ::google::protobuf::int32 BagRpcDeblockingReply::bagtype() const {
  return bagtype_;
}
inline void BagRpcDeblockingReply::set_bagtype(::google::protobuf::int32 value) {
  set_has_bagtype();
  bagtype_ = value;
}

// optional sint32 CurCapacity = 3 [default = -1];
inline bool BagRpcDeblockingReply::has_curcapacity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BagRpcDeblockingReply::set_has_curcapacity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BagRpcDeblockingReply::clear_has_curcapacity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BagRpcDeblockingReply::clear_curcapacity() {
  curcapacity_ = -1;
  clear_has_curcapacity();
}
inline ::google::protobuf::int32 BagRpcDeblockingReply::curcapacity() const {
  return curcapacity_;
}
inline void BagRpcDeblockingReply::set_curcapacity(::google::protobuf::int32 value) {
  set_has_curcapacity();
  curcapacity_ = value;
}

// -------------------------------------------------------------------

// BagRpcTakeItemAsk

// optional sint32 FromBagType = 1 [default = -1];
inline bool BagRpcTakeItemAsk::has_frombagtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BagRpcTakeItemAsk::set_has_frombagtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BagRpcTakeItemAsk::clear_has_frombagtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BagRpcTakeItemAsk::clear_frombagtype() {
  frombagtype_ = -1;
  clear_has_frombagtype();
}
inline ::google::protobuf::int32 BagRpcTakeItemAsk::frombagtype() const {
  return frombagtype_;
}
inline void BagRpcTakeItemAsk::set_frombagtype(::google::protobuf::int32 value) {
  set_has_frombagtype();
  frombagtype_ = value;
}

// optional sint32 ToBagType = 2 [default = -1];
inline bool BagRpcTakeItemAsk::has_tobagtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BagRpcTakeItemAsk::set_has_tobagtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BagRpcTakeItemAsk::clear_has_tobagtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BagRpcTakeItemAsk::clear_tobagtype() {
  tobagtype_ = -1;
  clear_has_tobagtype();
}
inline ::google::protobuf::int32 BagRpcTakeItemAsk::tobagtype() const {
  return tobagtype_;
}
inline void BagRpcTakeItemAsk::set_tobagtype(::google::protobuf::int32 value) {
  set_has_tobagtype();
  tobagtype_ = value;
}

// optional sint32 FromPos = 3 [default = -1];
inline bool BagRpcTakeItemAsk::has_frompos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BagRpcTakeItemAsk::set_has_frompos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BagRpcTakeItemAsk::clear_has_frompos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BagRpcTakeItemAsk::clear_frompos() {
  frompos_ = -1;
  clear_has_frompos();
}
inline ::google::protobuf::int32 BagRpcTakeItemAsk::frompos() const {
  return frompos_;
}
inline void BagRpcTakeItemAsk::set_frompos(::google::protobuf::int32 value) {
  set_has_frompos();
  frompos_ = value;
}

// -------------------------------------------------------------------

// BagRpcTakeItemReply

// optional sint32 Result = 1 [default = -9999];
inline bool BagRpcTakeItemReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BagRpcTakeItemReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BagRpcTakeItemReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BagRpcTakeItemReply::clear_result() {
  result_ = -9999;
  clear_has_result();
}
inline ::google::protobuf::int32 BagRpcTakeItemReply::result() const {
  return result_;
}
inline void BagRpcTakeItemReply::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .ItemObj ToItemObj = 2;
inline bool BagRpcTakeItemReply::has_toitemobj() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BagRpcTakeItemReply::set_has_toitemobj() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BagRpcTakeItemReply::clear_has_toitemobj() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BagRpcTakeItemReply::clear_toitemobj() {
  if (toitemobj_ != NULL) toitemobj_->::ItemObj::Clear();
  clear_has_toitemobj();
}
inline const ::ItemObj& BagRpcTakeItemReply::toitemobj() const {
  return toitemobj_ != NULL ? *toitemobj_ : *default_instance_->toitemobj_;
}
inline ::ItemObj* BagRpcTakeItemReply::mutable_toitemobj() {
  set_has_toitemobj();
  if (toitemobj_ == NULL) toitemobj_ = new ::ItemObj;
  return toitemobj_;
}
inline ::ItemObj* BagRpcTakeItemReply::release_toitemobj() {
  clear_has_toitemobj();
  ::ItemObj* temp = toitemobj_;
  toitemobj_ = NULL;
  return temp;
}
inline void BagRpcTakeItemReply::set_allocated_toitemobj(::ItemObj* toitemobj) {
  delete toitemobj_;
  toitemobj_ = toitemobj;
  if (toitemobj) {
    set_has_toitemobj();
  } else {
    clear_has_toitemobj();
  }
}

// optional .ItemObj FromItemObj = 3;
inline bool BagRpcTakeItemReply::has_fromitemobj() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BagRpcTakeItemReply::set_has_fromitemobj() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BagRpcTakeItemReply::clear_has_fromitemobj() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BagRpcTakeItemReply::clear_fromitemobj() {
  if (fromitemobj_ != NULL) fromitemobj_->::ItemObj::Clear();
  clear_has_fromitemobj();
}
inline const ::ItemObj& BagRpcTakeItemReply::fromitemobj() const {
  return fromitemobj_ != NULL ? *fromitemobj_ : *default_instance_->fromitemobj_;
}
inline ::ItemObj* BagRpcTakeItemReply::mutable_fromitemobj() {
  set_has_fromitemobj();
  if (fromitemobj_ == NULL) fromitemobj_ = new ::ItemObj;
  return fromitemobj_;
}
inline ::ItemObj* BagRpcTakeItemReply::release_fromitemobj() {
  clear_has_fromitemobj();
  ::ItemObj* temp = fromitemobj_;
  fromitemobj_ = NULL;
  return temp;
}
inline void BagRpcTakeItemReply::set_allocated_fromitemobj(::ItemObj* fromitemobj) {
  delete fromitemobj_;
  fromitemobj_ = fromitemobj;
  if (fromitemobj) {
    set_has_fromitemobj();
  } else {
    clear_has_fromitemobj();
  }
}

// optional sint32 FromBagType = 4 [default = -1];
inline bool BagRpcTakeItemReply::has_frombagtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BagRpcTakeItemReply::set_has_frombagtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BagRpcTakeItemReply::clear_has_frombagtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BagRpcTakeItemReply::clear_frombagtype() {
  frombagtype_ = -1;
  clear_has_frombagtype();
}
inline ::google::protobuf::int32 BagRpcTakeItemReply::frombagtype() const {
  return frombagtype_;
}
inline void BagRpcTakeItemReply::set_frombagtype(::google::protobuf::int32 value) {
  set_has_frombagtype();
  frombagtype_ = value;
}

// optional sint32 ToBagType = 5 [default = -1];
inline bool BagRpcTakeItemReply::has_tobagtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BagRpcTakeItemReply::set_has_tobagtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BagRpcTakeItemReply::clear_has_tobagtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BagRpcTakeItemReply::clear_tobagtype() {
  tobagtype_ = -1;
  clear_has_tobagtype();
}
inline ::google::protobuf::int32 BagRpcTakeItemReply::tobagtype() const {
  return tobagtype_;
}
inline void BagRpcTakeItemReply::set_tobagtype(::google::protobuf::int32 value) {
  set_has_tobagtype();
  tobagtype_ = value;
}

// -------------------------------------------------------------------

// BagRpcTidyAsk

// optional sint32 BagType = 2 [default = -1];
inline bool BagRpcTidyAsk::has_bagtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BagRpcTidyAsk::set_has_bagtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BagRpcTidyAsk::clear_has_bagtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BagRpcTidyAsk::clear_bagtype() {
  bagtype_ = -1;
  clear_has_bagtype();
}
inline ::google::protobuf::int32 BagRpcTidyAsk::bagtype() const {
  return bagtype_;
}
inline void BagRpcTidyAsk::set_bagtype(::google::protobuf::int32 value) {
  set_has_bagtype();
  bagtype_ = value;
}

// -------------------------------------------------------------------

// BagRpcTidyReply

// optional sint32 Result = 1 [default = -9999];
inline bool BagRpcTidyReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BagRpcTidyReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BagRpcTidyReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BagRpcTidyReply::clear_result() {
  result_ = -9999;
  clear_has_result();
}
inline ::google::protobuf::int32 BagRpcTidyReply::result() const {
  return result_;
}
inline void BagRpcTidyReply::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// repeated .BagData Bags = 3;
inline int BagRpcTidyReply::bags_size() const {
  return bags_.size();
}
inline void BagRpcTidyReply::clear_bags() {
  bags_.Clear();
}
inline const ::BagData& BagRpcTidyReply::bags(int index) const {
  return bags_.Get(index);
}
inline ::BagData* BagRpcTidyReply::mutable_bags(int index) {
  return bags_.Mutable(index);
}
inline ::BagData* BagRpcTidyReply::add_bags() {
  return bags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BagData >&
BagRpcTidyReply::bags() const {
  return bags_;
}
inline ::google::protobuf::RepeatedPtrField< ::BagData >*
BagRpcTidyReply::mutable_bags() {
  return &bags_;
}

// optional sint32 BagType = 4 [default = -1];
inline bool BagRpcTidyReply::has_bagtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BagRpcTidyReply::set_has_bagtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BagRpcTidyReply::clear_has_bagtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BagRpcTidyReply::clear_bagtype() {
  bagtype_ = -1;
  clear_has_bagtype();
}
inline ::google::protobuf::int32 BagRpcTidyReply::bagtype() const {
  return bagtype_;
}
inline void BagRpcTidyReply::set_bagtype(::google::protobuf::int32 value) {
  set_has_bagtype();
  bagtype_ = value;
}

// -------------------------------------------------------------------

// BagRpcTakeAllBackBagsAsk

// -------------------------------------------------------------------

// BagRpcTakeAllBackBagsReply

// optional sint32 Result = 1 [default = -9999];
inline bool BagRpcTakeAllBackBagsReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BagRpcTakeAllBackBagsReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BagRpcTakeAllBackBagsReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BagRpcTakeAllBackBagsReply::clear_result() {
  result_ = -9999;
  clear_has_result();
}
inline ::google::protobuf::int32 BagRpcTakeAllBackBagsReply::result() const {
  return result_;
}
inline void BagRpcTakeAllBackBagsReply::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// repeated .BagData Bags = 2;
inline int BagRpcTakeAllBackBagsReply::bags_size() const {
  return bags_.size();
}
inline void BagRpcTakeAllBackBagsReply::clear_bags() {
  bags_.Clear();
}
inline const ::BagData& BagRpcTakeAllBackBagsReply::bags(int index) const {
  return bags_.Get(index);
}
inline ::BagData* BagRpcTakeAllBackBagsReply::mutable_bags(int index) {
  return bags_.Mutable(index);
}
inline ::BagData* BagRpcTakeAllBackBagsReply::add_bags() {
  return bags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BagData >&
BagRpcTakeAllBackBagsReply::bags() const {
  return bags_;
}
inline ::google::protobuf::RepeatedPtrField< ::BagData >*
BagRpcTakeAllBackBagsReply::mutable_bags() {
  return &bags_;
}

// -------------------------------------------------------------------

// BagRpcBagChangeNotify

// optional sint32 Result = 1 [default = -9999];
inline bool BagRpcBagChangeNotify::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BagRpcBagChangeNotify::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BagRpcBagChangeNotify::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BagRpcBagChangeNotify::clear_result() {
  result_ = -9999;
  clear_has_result();
}
inline ::google::protobuf::int32 BagRpcBagChangeNotify::result() const {
  return result_;
}
inline void BagRpcBagChangeNotify::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .BagData Bags = 2;
inline bool BagRpcBagChangeNotify::has_bags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BagRpcBagChangeNotify::set_has_bags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BagRpcBagChangeNotify::clear_has_bags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BagRpcBagChangeNotify::clear_bags() {
  if (bags_ != NULL) bags_->::BagData::Clear();
  clear_has_bags();
}
inline const ::BagData& BagRpcBagChangeNotify::bags() const {
  return bags_ != NULL ? *bags_ : *default_instance_->bags_;
}
inline ::BagData* BagRpcBagChangeNotify::mutable_bags() {
  set_has_bags();
  if (bags_ == NULL) bags_ = new ::BagData;
  return bags_;
}
inline ::BagData* BagRpcBagChangeNotify::release_bags() {
  clear_has_bags();
  ::BagData* temp = bags_;
  bags_ = NULL;
  return temp;
}
inline void BagRpcBagChangeNotify::set_allocated_bags(::BagData* bags) {
  delete bags_;
  bags_ = bags;
  if (bags) {
    set_has_bags();
  } else {
    clear_has_bags();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_BagRpc_2eproto__INCLUDED
